name: Build Sliver Server for CentOS 5.11 i686

on:
  workflow_dispatch:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # 获取完整历史以便git describe能够工作
          
      - name: Set up Docker
        uses: docker/setup-buildx-action@v2
        
      - name: Create Dockerfile for Alpine
        run: |
          echo "FROM golang:1.22.2-alpine3.19" > Dockerfile.alpine
          echo "" >> Dockerfile.alpine
          echo "# Install basic build tools and dependencies" >> Dockerfile.alpine
          echo "RUN apk add --no-cache build-base git ca-certificates upx curl bash zip unzip xz" >> Dockerfile.alpine
          echo "" >> Dockerfile.alpine
          echo "# Set working directory" >> Dockerfile.alpine
          echo "WORKDIR /build" >> Dockerfile.alpine
          echo "" >> Dockerfile.alpine
          echo "# Set environment variables" >> Dockerfile.alpine
          echo "ENV CGO_ENABLED=0" >> Dockerfile.alpine
          echo "ENV GOOS=linux" >> Dockerfile.alpine
          echo "ENV GOARCH=386" >> Dockerfile.alpine

      - name: Build Docker image
        run: docker build -t sliver-build -f Dockerfile.alpine .

      - name: Prepare patched asset files
        run: |
          # Create directory structure
          mkdir -p ./server/assets/
          
          # Fix GetZigDir() calls in server/gogo/go.go
          if [ -f ./server/gogo/go.go ]; then
            # Replace all calls without parameters, add GOOS and GOARCH parameters
            sed -i 's/GetZigDir()/GetZigDir("linux", "386")/g' ./server/gogo/go.go
            
            # Print modified file to verify replacement
            echo "Checking modified gogo/go.go file:"
            grep -n "GetZigDir" ./server/gogo/go.go
          fi
          
          # Create patch script to fix integer overflow in configs/crack.go
          echo "#!/bin/bash" > fix_crack.sh
          echo "set -e" >> fix_crack.sh
          echo "" >> fix_crack.sh
          echo "# Check if file exists" >> fix_crack.sh
          echo "if [ ! -f ./server/configs/crack.go ]; then" >> fix_crack.sh
          echo "  echo \"Error: crack.go not found\"" >> fix_crack.sh
          echo "  exit 1" >> fix_crack.sh
          echo "fi" >> fix_crack.sh
          echo "" >> fix_crack.sh
          echo "# Read original content" >> fix_crack.sh
          echo "ORIG_CONTENT=\$(cat ./server/configs/crack.go)" >> fix_crack.sh
          echo "" >> fix_crack.sh
          echo "# Show original content around line 104" >> fix_crack.sh
          echo "echo \"Original content around line 104:\"" >> fix_crack.sh
          echo "echo \"\$ORIG_CONTENT\" | sed -n \"100,110p\"" >> fix_crack.sh
          echo "" >> fix_crack.sh
          echo "# Replace all occurrences of the integer" >> fix_crack.sh
          echo "NEW_CONTENT=\$(echo \"\$ORIG_CONTENT\" | sed \"s/10737418240/int64(10737418240)/g\")" >> fix_crack.sh
          echo "" >> fix_crack.sh
          echo "# Check replacement result" >> fix_crack.sh
          echo "echo \"Replaced content around line 104:\"" >> fix_crack.sh
          echo "echo \"\$NEW_CONTENT\" | sed -n \"100,110p\"" >> fix_crack.sh
          echo "" >> fix_crack.sh
          echo "# Save to new file" >> fix_crack.sh
          echo "echo \"\$NEW_CONTENT\" > ./server/configs/crack.go.new" >> fix_crack.sh
          echo "" >> fix_crack.sh
          echo "# Verify if replacement was successful" >> fix_crack.sh
          echo "if grep -q \"int64(10737418240)\" ./server/configs/crack.go.new; then" >> fix_crack.sh
          echo "  echo \"Replacement successful, applying new file\"" >> fix_crack.sh
          echo "  mv ./server/configs/crack.go.new ./server/configs/crack.go" >> fix_crack.sh
          echo "else" >> fix_crack.sh
          echo "  echo \"Replacement failed, trying direct line replacement\"" >> fix_crack.sh
          echo "  # Replace specific line 104" >> fix_crack.sh
          echo "  LINE_104=\$(echo \"\$ORIG_CONTENT\" | sed -n \"104p\")" >> fix_crack.sh
          echo "  FIXED_LINE_104=\$(echo \"\$LINE_104\" | sed \"s/10737418240/int64(10737418240)/g\")" >> fix_crack.sh
          echo "  " >> fix_crack.sh
          echo "  echo \"Original line 104: \$LINE_104\"" >> fix_crack.sh
          echo "  echo \"Fixed line 104: \$FIXED_LINE_104\"" >> fix_crack.sh
          echo "  " >> fix_crack.sh
          echo "  # Build new file with replaced line" >> fix_crack.sh
          echo "  echo \"\$ORIG_CONTENT\" | sed \"104s/.*/${FIXED_LINE_104}/\" > ./server/configs/crack.go.new2" >> fix_crack.sh
          echo "  mv ./server/configs/crack.go.new2 ./server/configs/crack.go" >> fix_crack.sh
          echo "fi" >> fix_crack.sh
          echo "" >> fix_crack.sh
          echo "# Final check" >> fix_crack.sh
          echo "grep -n \"defaultMaxFileSize\" ./server/configs/crack.go" >> fix_crack.sh
          echo "grep -n \"10737418240\" ./server/configs/crack.go || echo \"All integer values have been replaced\"" >> fix_crack.sh
          
          # Make script executable and run it
          chmod +x fix_crack.sh
          ./fix_crack.sh
          
          # Ultimate solution: if all replacement methods fail, create a new file without issues
          if [ -f ./server/configs/crack.go ]; then
            echo "Creating a backup crack.go file with fixed integer types"
            echo '// Package configs contains server configuration settings
package configs

import (
	"encoding/json"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"time"

	"github.com/bishopfox/sliver/protobuf/clientpb"
	"github.com/sirupsen/logrus"
)

const (
	crackConfigFileName = "crack.json"
)

var (
	crackConfigLog = logrus.WithField("config", "crack")
)

// CrackConfig - Config related to attack surface
type CrackConfig struct {
	HashcatPath     string   `json:"hashcat_path"`
	JohnPath        string   `json:"john_path"`
	WordlistPath    string   `json:"wordlist_path"`
	RulesPath       string   `json:"rules_path"`
	AttackModes     []int    `json:"attack_modes"`
	DefaultCharsets []string `json:"default_charsets"`
	FileFormats     []string `json:"file_formats"`
	MaxFileSize     int64    `json:"max_file_size"`
}

// GetCrackConfigPath - Get the config path
func GetCrackConfigPath() string {
	appDir := GetRootAppDir()
	mk(filepath.Join(appDir, ".sliver-client"))
	return filepath.Join(appDir, ".sliver-client", crackConfigFileName)
}

// SaveCrackConfig - Save config to disk
func SaveCrackConfig(config *CrackConfig) error {
	if config.MaxFileSize == 0 {
		defaultMaxFileSize := int64(10737418240)
		config.MaxFileSize = defaultMaxFileSize
		crackConfigLog.Warnf("MaxFileSize not configured - defaulting to %d", defaultMaxFileSize)
	}
	configPath := GetCrackConfigPath()
	configJSON, _ := json.MarshalIndent(config, "", "    ")
	return ioutil.WriteFile(configPath, configJSON, 0o600)
}

// GetCrackConfig - Returns the current config
func GetCrackConfig() *CrackConfig {
	configPath := GetCrackConfigPath()
	config := getCrackConfigFromDisk(configPath)
	if config == nil {
		config = &CrackConfig{
			MaxFileSize: int64(10737418240),
			AttackModes: []int{0, 3},
			DefaultCharsets: []string{
				"?l?d?u", "?l?d", "?l?d?s", "?a",
			},
			FileFormats: []string{
				"hccapx", "pcap", "ntds", "sam", "security", "system",
				"zip", "pfx", "rar", "pdf", "doc", "docx",
				"xls", "xlsx", "ppt", "pptx", "odt",
				"gz", "tar", "7z", "luks",
			},
		}
		saveErr := SaveCrackConfig(config)
		if saveErr != nil {
			crackConfigLog.Errorf("Failed to save config: %s", saveErr)
		}
	}
	return config
}

func getCrackConfigFromDisk(path string) *CrackConfig {
	_, err := os.Stat(path)
	if os.IsNotExist(err) {
		return nil
	}
	data, err := ioutil.ReadFile(path)
	if err != nil {
		crackConfigLog.Errorf("Failed to read config file: %s", err)
		return nil
	}
	config := &CrackConfig{}
	err = json.Unmarshal(data, config)
	if err != nil {
		crackConfigLog.Errorf("Failed to parse cofnig file: %s", err)
		return nil
	}
	return config
}

// CrackCiphers - Returns the supported ciphers
func CrackCiphers() []string {
	return []string{
		"zip",
		"zip2",
		"rar",
		"rar5",
		"pdf",
		"luks",
		"7z",
		"office",
		"office2007",
		"office2010",
		"office2013",
		"itunes",
	}
}

// CrackListHashes - Returns list of hashes, cracks, sessions, etc
func CrackListHashes() *clientpb.CrackList {
	result := &clientpb.CrackList{}
	appDir := GetRootAppDir()
	hashcatDir := path.Join(appDir, ".sliver-client", "hashcat")
	if _, err := os.Stat(hashcatDir); os.IsNotExist(err) {
		crackConfigLog.Infof("The folder \"%s\" does not exist.", hashcatDir)
		return result
	}
	files, err := os.ReadDir(hashcatDir)
	if err != nil {
		crackConfigLog.Errorf("Failed to list directory: %s", err)
		return result
	}

	// Loop over files, check if they are valid hashcat outfiles
	for _, file := range files {
		if file.IsDir() || file.Name() == "hashcat.potfile" || filepath.Ext(file.Name()) != ".out" {
			continue
		}
		path := path.Join(hashcatDir, file.Name())
		stats, err := file.Info()
		if err != nil {
			crackConfigLog.Errorf("Failed to get file stats: %s", err)
			continue
		}

		// Skip outfiles that are too old
		if time.Now().Sub(stats.ModTime()) > 356*24*time.Hour {
			continue
		}

		// Extract stats
		// TODO: add more details
		estimatedCompletionDuration := ""
		estimatedCompletionDate := ""

		name := file.Name()[:len(file.Name())-4]
		fileInfo := &clientpb.CrackFile{
			Name:                        name,
			Path:                        path,
			ModTime:                     stats.ModTime().Format(time.RFC3339),
			Size:                        stats.Size(),
			EstimatedCompletionDuration: estimatedCompletionDuration,
			EstimatedCompletionDate:     estimatedCompletionDate,
		}

		// Parse the outfile and extract additional info
		data, err := ioutil.ReadFile(path)
		if err != nil {
			crackConfigLog.Errorf("Failed to read file: %s", err)
			continue
		}

		lines := []string{}
		var lineStatus string
		var prevLineStatus string
		var cracked bool
		var i int
		var totalHashCount int
		var crackedHashCount int
		var status string
		var lastProgress string
		for _, line := range string(data) {
			if line == '\n' {
				lines = append(lines, lineStatus)
				lineStatus = ""
				continue
			}
			lineStatus += string(line)
		}
		if lineStatus != "" {
			lines = append(lines, lineStatus)
		}

		for i = 0; i < len(lines); i++ {
			line := lines[i]
			if len(line) > 18 && line[:18] == "Started: " {
				fileInfo.StartedAt = line[9:]
			}
			if len(line) > 10 && line[:10] == "Recovered:" {
				parts := line[11:]
				nums := []int{}
				var num string
				for _, c := range parts {
					if c >= '0' && c <= '9' {
						num += string(c)
					} else if num != "" {
						n, err := strconv.Atoi(num)
						if err != nil {
							crackConfigLog.Debugf("Failed to parse number: %s", err)
							num = ""
							continue
						}
						nums = append(nums, n)
						num = ""
					}
				}
				if len(nums) >= 2 {
					// Note: this can be a string like "1/0 (inf%)"
					crackedHashCount = nums[0]
					totalHashCount = nums[1]
					if totalHashCount == 0 {
						totalHashCount = 1
					}
				}
			} else if len(line) > 7 && line[:7] == "Status:" {
				status = line[8:]
				if status == "Cracked" {
					cracked = true
				}
			} else if len(line) > 10 && line[:10] == "Progress: " {
				lastProgress = line[10:]
			}
		}

		if cracked {
			// Find all cracked creds
			fileInfo.Status = "Cracked"
			var results []*clientpb.CrackResult
			for i = 0; i < len(lines); i++ {
				line := lines[i]
				// The creds are display as hash:pwd, after the Status: line
				if prevLineStatus == "Status: Cracked" && line != "" {
					parts := []rune(line)
					colonPos := -1
					for j, c := range parts {
						if c == ':' {
							colonPos = j
							break
						}
					}
					if colonPos == -1 {
						continue
					}
					hash := string(parts[:colonPos])
					pwd := string(parts[colonPos+1:])
					results = append(results, &clientpb.CrackResult{
						Hash:     hash,
						Password: pwd,
					})
				}
				prevLineStatus = line
			}
			fileInfo.Results = results
		} else {
			fileInfo.Status = "Running (" + lastProgress + ")"
		}
		fileInfo.CrackedHashes = int64(crackedHashCount)
		fileInfo.TotalHashes = int64(totalHashCount)

		result.Files = append(result.Files, fileInfo)
	}

	return result
}

// GetRootAppDir - Get the Sliver app dir
func GetRootAppDir() string {
	appDir, err := os.Executable()
	if err != nil {
		panic(err)
	}
	return filepath.Dir(appDir)
}

func mk(dir string) {
	os.MkdirAll(dir, 0o700)
}

      - name: Build Sliver for CentOS 5.11
        run: |
          # 创建build.sh脚本
          echo "#!/bin/sh" > build.sh
          echo "set -e" >> build.sh
          echo "" >> build.sh
          echo "# Configure Git safe directory" >> build.sh
          echo "git config --global --add safe.directory /build" >> build.sh
          echo "" >> build.sh
          echo "# Fix integer overflow in configs/crack.go inside the container" >> build.sh
          echo "if [ -f /build/server/configs/crack.go ]; then" >> build.sh
          echo "  echo \"===== Fixing crack.go in build container =====\" " >> build.sh
          echo "  cat /build/server/configs/crack.go | sed \"s/10737418240/int64(10737418240)/g\" > /tmp/crack.go" >> build.sh
          echo "  mv /tmp/crack.go /build/server/configs/crack.go" >> build.sh
          echo "  " >> build.sh
          echo "  # Show the modified file" >> build.sh
          echo "  echo \"Content around line 104:\"" >> build.sh
          echo "  sed -n \"100,110p\" /build/server/configs/crack.go " >> build.sh
          echo "fi" >> build.sh
          echo "" >> build.sh
          echo "# Set version information" >> build.sh
          echo "export VERSION=\$(git describe --abbrev=0 || echo \"v0.0.0\")" >> build.sh
          echo "export COMPILED_AT=\$(date +%s)" >> build.sh
          echo "export RELEASES_URL=\"https://api.github.com/repos/BishopFox/sliver/releases\"" >> build.sh
          echo "export GIT_COMMIT=\$(git rev-parse HEAD || echo \"unknown\")" >> build.sh
          echo "export GIT_DIRTY=\$(git diff --quiet || echo \"Dirty\")" >> build.sh
          echo "export ARMORY_PUBLIC_KEY=\"RWSBpxpRWDrD7Fe+VvRE3c2VEDC2NK80rlNCj+BX0gz44Xw07r6KQD9L\"" >> build.sh
          echo "export ARMORY_REPO_URL=\"https://api.github.com/repos/sliverarmory/armory/releases\"" >> build.sh
          echo "" >> build.sh
          echo "# Set build flags" >> build.sh
          echo "export LDFLAGS=\"-s -w \\" >> build.sh
          echo "  -extldflags \\\"-static -Wl,--strip-all\\\" \\" >> build.sh
          echo "  -X github.com/bishopfox/sliver/client/version.Version=\${VERSION} \\" >> build.sh
          echo "  -X github.com/bishopfox/sliver/client/version.CompiledAt=\${COMPILED_AT} \\" >> build.sh
          echo "  -X github.com/bishopfox/sliver/client/version.GithubReleasesURL=\${RELEASES_URL} \\" >> build.sh
          echo "  -X github.com/bishopfox/sliver/client/version.GitCommit=\${GIT_COMMIT} \\" >> build.sh
          echo "  -X github.com/bishopfox/sliver/client/version.GitDirty=\${GIT_DIRTY} \\" >> build.sh
          echo "  -X github.com/bishopfox/sliver/client/assets.DefaultArmoryPublicKey=\${ARMORY_PUBLIC_KEY} \\" >> build.sh
          echo "  -X github.com/bishopfox/sliver/client/assets.DefaultArmoryRepoURL=\${ARMORY_REPO_URL}\"" >> build.sh
          echo "" >> build.sh
          echo "# Ensure vendor directory exists" >> build.sh
          echo "go mod vendor || echo \"Vendor modules already present\"" >> build.sh
          echo "" >> build.sh
          echo "# Build the server - using no_assets tag to skip asset embedding" >> build.sh
          echo "echo \"Building sliver-server for CentOS 5.11 i686...\"" >> build.sh
          echo "go build -mod=vendor -trimpath -tags \"netgo,osusergo,no_assets,server\" -ldflags \"\${LDFLAGS}\" -o /build/sliver-server-centos5-i686 ./server" >> build.sh
          echo "" >> build.sh
          echo "# Compress the binary with UPX" >> build.sh
          echo "echo \"Compressing the binary...\"" >> build.sh
          echo "upx -9 /build/sliver-server-centos5-i686" >> build.sh
          echo "" >> build.sh
          echo "# Verify build result" >> build.sh
          echo "file /build/sliver-server-centos5-i686" >> build.sh
          echo "" >> build.sh
          echo "# Check if the file exists" >> build.sh
          echo "ls -la /build/sliver-server-centos5-i686" >> build.sh
          echo "" >> build.sh
          echo "# Ensure file has execution permissions" >> build.sh
          echo "chmod +x /build/sliver-server-centos5-i686" >> build.sh
          
          # 使脚本可执行
          chmod +x build.sh
          
          # 在Docker容器中运行构建
          docker run -v $(pwd):/build sliver-build /bin/sh -c "cd /build && (./build.sh 2>&1 | tee /tmp/build.log) && ls -la /build/ && cp -v /build/sliver-server-centos5-i686 /build/ || (echo '======= BUILD ERROR =======' && cat /tmp/build.log && false)"

      - name: Verify patched files
        if: failure()
        run: |
          echo "Build failed, checking if files were patched correctly:"
          
          echo "Checking defaultMaxFileSize in configs/crack.go:"
          grep -n "defaultMaxFileSize" ./server/configs/crack.go || echo "defaultMaxFileSize not found"
          grep -n "10737418240" ./server/configs/crack.go || echo "All integer values have been replaced"
          grep -n "int64" ./server/configs/crack.go || echo "No int64 conversion found"
          
          echo "Showing lines around line 104:"
          if [ -f ./server/configs/crack.go ]; then
            echo "======= Content around line 104 ======="
            sed -n '99,110p' ./server/configs/crack.go
          fi
          
          echo "Checking GetZigDir calls:"
          grep -n "GetZigDir" ./server/gogo/go.go || echo "No GetZigDir calls found"
          
          echo "Checking GetZigDir function definition in assets.go:"
          grep -n "func GetZigDir" ./server/assets/assets.go || echo "GetZigDir function not found"
          
          echo "Checking error log:"
          cat /tmp/build.log || echo "No build log found"

      - name: Test binary compatibility
        run: |
          # List files in current directory
          echo "Files in current directory:"
          ls -la ./
          
          # Verify binary is a statically linked 32-bit executable
          if [ -f ./sliver-server-centos5-i686 ]; then
            file ./sliver-server-centos5-i686
            ldd ./sliver-server-centos5-i686 || echo "Binary is static (expected)"
          else
            echo "Binary not found, checking other locations..."
            find ./ -name "sliver-server-centos5-i686" -type f
          fi
      
      # Ensure file exists with correct permissions
      - name: Verify file existence and permissions
        run: |
          ls -la ./sliver-server-centos5-i686 || echo "Binary not found in expected location"
          [ -f ./sliver-server-centos5-i686 ] && chmod +x ./sliver-server-centos5-i686

      - name: Upload sliver server
        uses: actions/upload-artifact@v4
        with:
          name: sliver-server-centos5-i686
          path: |
            ./sliver-server-centos5-i686
            /build/sliver-server-centos5-i686
          if-no-files-found: warn
          
      - name: Create README
        run: |
          echo "# Sliver Server for CentOS 5.11 i686" > README-centos5-i686.md
          echo "" >> README-centos5-i686.md
          echo "This build is specifically designed for older CentOS 5.11 i686 systems, with the following build configuration:" >> README-centos5-i686.md
          echo "" >> README-centos5-i686.md
          echo "- Based on statically compiled Go application" >> README-centos5-i686.md
          echo "- Uses Alpine for cross-compilation" >> README-centos5-i686.md
          echo "- Target system: Linux 2.6.18 kernel, glibc 2.5" >> README-centos5-i686.md
          echo "- Build features:" >> README-centos5-i686.md
          echo "  - Static linking (no external dependencies)" >> README-centos5-i686.md
          echo "  - 32-bit i686 architecture" >> README-centos5-i686.md
          echo "  - UPX compression to reduce file size" >> README-centos5-i686.md
          echo "" >> README-centos5-i686.md
          echo "## Usage" >> README-centos5-i686.md
          echo "" >> README-centos5-i686.md
          echo "1. Download the binary file" >> README-centos5-i686.md
          echo "2. Grant execution permissions: \`chmod +x sliver-server-centos5-i686\`" >> README-centos5-i686.md
          echo "3. Run the server: \`./sliver-server-centos5-i686\`" >> README-centos5-i686.md
          echo "" >> README-centos5-i686.md
          echo "On first run, the server will generate the required configuration files and certificates." >> README-centos5-i686.md
          echo "" >> README-centos5-i686.md
          echo "## Feature Limitations" >> README-centos5-i686.md
          echo "" >> README-centos5-i686.md
          echo "This version is built with the \`no_assets\` tag, meaning it does not include built-in resource packages (Go, compilers, etc.)." >> README-centos5-i686.md
          echo "If you need to use implant generation features, please manually place the necessary resources in the appropriate directories." >> README-centos5-i686.md
          echo "" >> README-centos5-i686.md
          echo "## Additional Notes" >> README-centos5-i686.md
          echo "" >> README-centos5-i686.md
          echo "- This binary is statically compiled, with no system library dependencies" >> README-centos5-i686.md
          echo "- For best compatibility, it is built using \`-extldflags \"-static\"\`" >> README-centos5-i686.md
          echo "- UPX compression is used; if you encounter issues, try decompressing it: \`upx -d sliver-server-centos5-i686\`" >> README-centos5-i686.md

      - name: Upload README
        uses: actions/upload-artifact@v4
        with:
          name: sliver-server-centos5-i686-docs
          path: README-centos5-i686.md 
