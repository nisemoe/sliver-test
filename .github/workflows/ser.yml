name: Build Sliver Server for CentOS 5.11 i686

on:
  workflow_dispatch:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # 获取完整历史以便git describe能够工作
          
      - name: Set up Docker
        uses: docker/setup-buildx-action@v2
        
      - name: Ensure assets script is executable
        run: |
          chmod +x go-assets.sh
          ls -la go-assets.sh
      - name: Create Dockerfile for Alpine
        run: |
          # 使用echo命令创建Dockerfile，避免heredoc语法问题
          echo 'FROM golang:1.22.2-alpine3.19' > Dockerfile.alpine
          echo '# 安装基本构建工具和依赖' >> Dockerfile.alpine
          echo 'RUN apk add --no-cache build-base git ca-certificates upx curl bash zip unzip xz' >> Dockerfile.alpine
          echo '# 设置工作目录' >> Dockerfile.alpine
          echo 'WORKDIR /build' >> Dockerfile.alpine
          echo '# 设置环境变量' >> Dockerfile.alpine
          echo 'ENV CGO_ENABLED=0' >> Dockerfile.alpine
          echo 'ENV GOOS=linux' >> Dockerfile.alpine
          echo 'ENV GOARCH=386' >> Dockerfile.alpine
      - name: Build Docker image
        run: docker build -t sliver-build -f Dockerfile.alpine .

      - name: Prepare patched asset files
        run: |
          # 创建目录结构
          mkdir -p ./server/assets/
          
          # 检查是否已经应用了修复
          if [ -f .overflow_fixed ]; then
            echo "已应用整数溢出修复，无需再次修复"
          fi
          
          if [ -f .zigdir_fixed ]; then
            echo "已应用GetZigDir调用修复，无需再次修复"
          fi
          
          # 使用echo命令创建assets-patch.sh脚本，避免heredoc语法问题
          echo '#!/bin/bash' > assets-patch.sh
          echo 'set -e' >> assets-patch.sh
          echo '' >> assets-patch.sh
          
          # 创建assets_generate.go文件
          echo 'cat > ./server/assets/assets_generate.go << '"'"'EOFILE'"'"'' >> assets-patch.sh
          echo '//go:build generate' >> assets-patch.sh
          echo '// +build generate' >> assets-patch.sh
          echo 'package assets' >> assets-patch.sh
          echo '// 这个文件用于go generate命令，但我们在编译时使用no_assets标签跳过它' >> assets-patch.sh
          echo '// 此文件不包含实际功能，仅为了满足编译要求' >> assets-patch.sh
          echo 'EOFILE' >> assets-patch.sh
          echo '' >> assets-patch.sh
          
          # 创建assets.go文件
          echo 'cat > ./server/assets/assets.go << '"'"'EOFILE'"'"'' >> assets-patch.sh
          echo '//go:build !generate && no_assets' >> assets-patch.sh
          echo '// +build !generate,no_assets' >> assets-patch.sh
          echo 'package assets' >> assets-patch.sh
          echo 'import (' >> assets-patch.sh
          echo '  "errors"' >> assets-patch.sh
          echo '  "io/fs"' >> assets-patch.sh
          echo '  "os"' >> assets-patch.sh
          echo '  "path/filepath"' >> assets-patch.sh
          echo '  "log"' >> assets-patch.sh
          echo ')' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// 定义常量' >> assets-patch.sh
          echo 'const (' >> assets-patch.sh
          echo '  GoDirName = "go"' >> assets-patch.sh
          echo '  ZigDirName = "zig"' >> assets-patch.sh
          echo ')' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// 自定义日志记录器' >> assets-patch.sh
          echo 'type Logger struct {' >> assets-patch.sh
          echo '    stdLogger *log.Logger' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo 'func (l *Logger) Info(args ...interface{}) {' >> assets-patch.sh
          echo '    l.stdLogger.Println(args...)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo 'func (l *Logger) Infof(format string, args ...interface{}) {' >> assets-patch.sh
          echo '    l.stdLogger.Printf(format, args...)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo 'func (l *Logger) Warn(args ...interface{}) {' >> assets-patch.sh
          echo '    l.stdLogger.Println("[WARN]", args)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo 'func (l *Logger) Warnf(format string, args ...interface{}) {' >> assets-patch.sh
          echo '    l.stdLogger.Printf("[WARN] "+format, args...)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo 'func (l *Logger) Error(args ...interface{}) {' >> assets-patch.sh
          echo '    l.stdLogger.Println("[ERROR]", args)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo 'func (l *Logger) Errorf(format string, args ...interface{}) {' >> assets-patch.sh
          echo '    l.stdLogger.Printf("[ERROR] "+format, args...)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo 'func (l *Logger) Debug(args ...interface{}) {' >> assets-patch.sh
          echo '    l.stdLogger.Println("[DEBUG]", args)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo 'func (l *Logger) Debugf(format string, args ...interface{}) {' >> assets-patch.sh
          echo '    l.stdLogger.Printf("[DEBUG] "+format, args...)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// 创建自定义日志记录器实例' >> assets-patch.sh
          echo 'var setupLog = &Logger{' >> assets-patch.sh
          echo '    stdLogger: log.New(os.Stderr, "assets: ", log.LstdFlags),' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// Setup - 初始化资产' >> assets-patch.sh
          echo 'func Setup() {' >> assets-patch.sh
          echo '    setupLog.Infof("[assets] Skip loading embedded assets (using no_assets tag)")' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// Asset - 实现Asset函数' >> assets-patch.sh
          echo 'func Asset(name string) ([]byte, error) {' >> assets-patch.sh
          echo '    setupLog.Debugf("Asset called for %s (not implemented in no_assets build)", name)' >> assets-patch.sh
          echo '    return []byte{}, errors.New("assets not available in this build")' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// AssetDir - 实现AssetDir函数' >> assets-patch.sh
          echo 'func AssetDir(name string) ([]string, error) {' >> assets-patch.sh
          echo '    setupLog.Debugf("AssetDir called for %s (not implemented in no_assets build)", name)' >> assets-patch.sh
          echo '    return []string{}, errors.New("assets not available in this build")' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// AssetInfo - 实现AssetInfo函数' >> assets-patch.sh
          echo 'func AssetInfo(name string) (fs.FileInfo, error) {' >> assets-patch.sh
          echo '    setupLog.Debugf("AssetInfo called for %s (not implemented in no_assets build)", name)' >> assets-patch.sh
          echo '    return nil, errors.New("assets not available in this build")' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '// GetTrafficEncoderDir - 获取流量编码器目录' >> assets-patch.sh
          echo 'func GetTrafficEncoderDir() string {' >> assets-patch.sh
          echo '    return filepath.Join(".", "traffic-encoders")' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// GetRootAppDir - 获取应用程序根目录' >> assets-patch.sh
          echo 'func GetRootAppDir() string {' >> assets-patch.sh
          echo '    exePath, err := os.Executable()' >> assets-patch.sh
          echo '    if err != nil {' >> assets-patch.sh
          echo '        setupLog.Errorf("Failed to get executable path: %s", err)' >> assets-patch.sh
          echo '        return "."' >> assets-patch.sh
          echo '    }' >> assets-patch.sh
          echo '    return filepath.Dir(exePath)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// GetZigDir - 获取Zig目录' >> assets-patch.sh
          echo 'func GetZigDir(targetOS string, targetArch string) string {' >> assets-patch.sh
          echo '    zigDir := filepath.Join(GetRootAppDir(), ".sliver-client", "zig")' >> assets-patch.sh
          echo '    if _, err := os.Stat(zigDir); os.IsNotExist(err) {' >> assets-patch.sh
          echo '        os.MkdirAll(zigDir, 0700)' >> assets-patch.sh
          echo '    }' >> assets-patch.sh
          echo '    return zigDir' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// 定义assetsFs变量' >> assets-patch.sh
          echo 'var assetsFs = &AssetFS{' >> assets-patch.sh
          echo '    Asset:    Asset,' >> assets-patch.sh
          echo '    AssetDir: AssetDir,' >> assets-patch.sh
          echo '    AssetInfo: AssetInfo,' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// AssetFS - 文件系统接口实现' >> assets-patch.sh
          echo 'type AssetFS struct {' >> assets-patch.sh
          echo '    Asset    func(name string) ([]byte, error)' >> assets-patch.sh
          echo '    AssetDir func(name string) ([]string, error)' >> assets-patch.sh
          echo '    AssetInfo func(name string) (fs.FileInfo, error)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// ReadFile - 添加的为了兼容assets-helpers.go的方法' >> assets-patch.sh
          echo 'func (a *AssetFS) ReadFile(name string) ([]byte, error) {' >> assets-patch.sh
          echo '    return a.Asset(name)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo '// 为了避免编译器报错，添加缺失的一些目录函数' >> assets-patch.sh
          echo 'func GetGoDirPath(goOS string, goArch string) string {' >> assets-patch.sh
          echo '    return filepath.Join(".", GoDirName, goOS, goArch) ' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo 'func GetGoZipPath(goOS string, goArch string) string {' >> assets-patch.sh
          echo '    return filepath.Join(GetGoDirPath(goOS, goArch), "go.zip")' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo 'func GetSGNPath(goOS string, goArch string) string {' >> assets-patch.sh
          echo '    return filepath.Join(".", "sgn", goOS, goArch)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo 'func GetGarblePath(goOS string, goArch string) string {' >> assets-patch.sh
          echo '    return filepath.Join(".", "garble", goOS, goArch) ' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo '' >> assets-patch.sh
          echo 'func GetZigPath(goOS string, goArch string) string {' >> assets-patch.sh
          echo '    return filepath.Join(".", ZigDirName, goOS, goArch)' >> assets-patch.sh
          echo '}' >> assets-patch.sh
          echo 'EOFILE' >> assets-patch.sh
          echo '' >> assets-patch.sh
          
          # 修复assets-helpers.go
          echo '# 创建assets-helpers.go的修复替换' >> assets-patch.sh
          echo '# 我们首先检查是否存在原始文件，如果存在则备份它' >> assets-patch.sh
          echo 'if [ -f ./server/assets/assets-helpers.go ]; then' >> assets-patch.sh
          echo '    cp ./server/assets/assets-helpers.go ./server/assets/assets-helpers.go.bak' >> assets-patch.sh
          echo '    # 尝试修复ReadFile错误' >> assets-patch.sh
          echo '    sed -i '"'"'s/assetsFs\.ReadFile/assetsFs\.Asset/g'"'"' ./server/assets/assets-helpers.go' >> assets-patch.sh
          echo 'fi' >> assets-patch.sh
          
          # 使脚本可执行并运行它
          chmod +x assets-patch.sh
          ./assets-patch.sh
          
          # 创建标记文件表示修复完成
          echo "=== assets.go has been patched ===" > /tmp/assets_patched
      - name: Apply critical fixes for 32-bit build
        run: |
          # 检查和修复configs/crack.go的整数溢出问题
          echo "检查configs/crack.go是否需要修复..."
          if grep -q "const defaultMaxFileSize = 10 \* 1024 \* 1024 \* 1024" ./server/configs/crack.go; then
            echo "发现defaultMaxFileSize可能导致32位溢出，需要修复..."
            
            # 直接运行sed命令而不使用heredoc
            echo "开始修复整数溢出问题..."
            
            # 备份原始文件
            cp ./server/configs/crack.go ./server/configs/crack.go.bak
            
            # 1. 修复整数常量定义为int64类型
            sed -i 's/const defaultMaxFileSize = 10 \* 1024 \* 1024 \* 1024/const defaultMaxFileSize int64 = 10 \* 1024 \* 1024 \* 1024/g' ./server/configs/crack.go
            sed -i 's/const defaultMaxDiskUsage = 5 \* defaultMaxFileSize/const defaultMaxDiskUsage int64 = 5 \* defaultMaxFileSize/g' ./server/configs/crack.go
            
            # 2. 修复结构体字段的类型
            sed -i 's/MaxFileSize  int/MaxFileSize  int64/g' ./server/configs/crack.go
            sed -i 's/MaxDiskUsage int/MaxDiskUsage int64/g' ./server/configs/crack.go
            
            # 3. 修复任何函数参数类型声明
            sed -i 's/MaxFileSize int /MaxFileSize int64 /g' ./server/configs/crack.go
            sed -i 's/MaxDiskUsage int /MaxDiskUsage int64 /g' ./server/configs/crack.go
            
            # 显示修复结果
            echo "------------------------------"
            echo "修复后的文件内容概览："
            echo "------------------------------"
            grep -n "defaultMaxFileSize" ./server/configs/crack.go
            grep -n "defaultMaxDiskUsage" ./server/configs/crack.go
            grep -n "MaxFileSize" ./server/configs/crack.go
            grep -n "MaxDiskUsage" ./server/configs/crack.go
            echo "------------------------------"
            
            # 创建标记文件供后续步骤检查
            echo "已应用整数溢出修复" > .overflow_fixed
          else
            echo "未发现需要修复的代码模式，跳过修复"
          fi
          
          # 检查和修复gogo/go.go中的GetZigDir调用
          echo "检查gogo/go.go中的GetZigDir调用..."
          if [ -f ./server/gogo/go.go ] && grep -q "GetZigDir()" ./server/gogo/go.go; then
            echo "发现无参数的GetZigDir调用，需要修复..."
            sed -i 's/GetZigDir()/GetZigDir("linux", "386")/g' ./server/gogo/go.go
            
            # 显示修复结果
            echo "修复后的GetZigDir调用："
            grep -n "GetZigDir" ./server/gogo/go.go
            
            # 创建标记文件供后续步骤检查
            echo "已应用GetZigDir修复" > .zigdir_fixed
          else
            echo "未发现需要修复的GetZigDir调用，或文件不存在"
          fi
      - name: Build Sliver for CentOS 5.11
        run: |
          # 创建build.sh脚本
          echo '#!/bin/sh' > build.sh
          echo 'set -e' >> build.sh
          
          echo '# 检查是否有补丁文件需要应用' >> build.sh
          echo 'if [ -f "/tmp/crack_patched" ]; then' >> build.sh
          echo '  echo "已应用配置文件补丁，继续构建..."' >> build.sh
          echo 'else' >> build.sh
          echo '  echo "警告：没有找到配置补丁标记，请确保已运行修复脚本"' >> build.sh
          echo 'fi' >> build.sh
          
          echo '# 配置Git安全目录' >> build.sh
          echo 'git config --global --add safe.directory /build' >> build.sh
          
          echo '# 设置版本信息' >> build.sh
          echo 'export VERSION=$(git describe --abbrev=0 || echo "v0.0.0")' >> build.sh
          echo 'export COMPILED_AT=$(date +%s)' >> build.sh
          echo 'export RELEASES_URL="https://api.github.com/repos/BishopFox/sliver/releases"' >> build.sh
          echo 'export GIT_COMMIT=$(git rev-parse HEAD || echo "unknown")' >> build.sh
          echo 'export GIT_DIRTY=$(git diff --quiet || echo '"'"'Dirty'"'"')' >> build.sh
          echo 'export ARMORY_PUBLIC_KEY="RWSBpxpRWDrD7Fe+VvRE3c2VEDC2NK80rlNCj+BX0gz44Xw07r6KQD9L"' >> build.sh
          echo 'export ARMORY_REPO_URL="https://api.github.com/repos/sliverarmory/armory/releases"' >> build.sh
          
          echo '# 设置构建标志' >> build.sh
          echo 'export LDFLAGS="-s -w \' >> build.sh
          echo '  -extldflags '"'"'-static -Wl,--strip-all'"'"' \' >> build.sh
          echo '  -X github.com/bishopfox/sliver/client/version.Version=${VERSION} \' >> build.sh
          echo '  -X github.com/bishopfox/sliver/client/version.CompiledAt=${COMPILED_AT} \' >> build.sh
          echo '  -X github.com/bishopfox/sliver/client/version.GithubReleasesURL=${RELEASES_URL} \' >> build.sh
          echo '  -X github.com/bishopfox/sliver/client/version.GitCommit=${GIT_COMMIT} \' >> build.sh
          echo '  -X github.com/bishopfox/sliver/client/version.GitDirty=${GIT_DIRTY} \' >> build.sh
          echo '  -X github.com/bishopfox/sliver/client/assets.DefaultArmoryPublicKey=${ARMORY_PUBLIC_KEY} \' >> build.sh
          echo '  -X github.com/bishopfox/sliver/client/assets.DefaultArmoryRepoURL=${ARMORY_REPO_URL}"' >> build.sh
          
          echo '# 确保vendor目录存在' >> build.sh
          echo 'go mod vendor || echo "Vendor modules already present"' >> build.sh
          
          echo '# 确认配置文件修正已应用' >> build.sh
          echo 'echo "检查configs/crack.go的修改："' >> build.sh
          echo 'if grep -q "defaultMaxFileSize int64" ./server/configs/crack.go; then' >> build.sh
          echo '  echo "✓ 已成功应用int64类型修复"' >> build.sh
          echo 'else' >> build.sh
          echo '  echo "⚠️ 警告：未找到int64类型声明，尝试现在应用修复"' >> build.sh
          echo '' >> build.sh
          echo '  # 紧急修复措施' >> build.sh
          echo '  sed -i '"'"'s/const defaultMaxFileSize = 10 \* 1024 \* 1024 \* 1024/const defaultMaxFileSize int64 = 10 \* 1024 \* 1024 \* 1024/g'"'"' ./server/configs/crack.go' >> build.sh
          echo '  sed -i '"'"'s/const defaultMaxDiskUsage = 5 \* defaultMaxFileSize/const defaultMaxDiskUsage int64 = 5 \* defaultMaxFileSize/g'"'"' ./server/configs/crack.go' >> build.sh
          echo '  sed -i '"'"'s/MaxFileSize  int/MaxFileSize  int64/g'"'"' ./server/configs/crack.go' >> build.sh
          echo '  sed -i '"'"'s/MaxDiskUsage int/MaxDiskUsage int64/g'"'"' ./server/configs/crack.go' >> build.sh
          echo '' >> build.sh
          echo '  echo "应用紧急修复后，再次检查："' >> build.sh
          echo '  grep -n "defaultMaxFileSize" ./server/configs/crack.go' >> build.sh
          echo 'fi' >> build.sh
          
          echo '# 构建服务器 - 这次使用no_assets标签跳过资产嵌入' >> build.sh
          echo 'echo "Building sliver-server for CentOS 5.11 i686..."' >> build.sh
          echo 'go build -mod=vendor -trimpath -tags "netgo,osusergo,no_assets,server" -ldflags "${LDFLAGS}" -o sliver-server-centos5-i686 ./server' >> build.sh
          
          echo '# 使用UPX进一步压缩二进制文件' >> build.sh
          echo 'echo "压缩二进制文件..."' >> build.sh
          echo 'upx -9 sliver-server-centos5-i686' >> build.sh
          
          echo '# 验证构建结果' >> build.sh
          echo 'file sliver-server-centos5-i686' >> build.sh
          
          echo '# 确保二进制文件确实存在并显示其大小' >> build.sh
          echo 'ls -la sliver-server-centos5-i686' >> build.sh
          echo 'echo "构建完成，二进制文件大小: $(du -h sliver-server-centos5-i686 | cut -f1)"' >> build.sh
          
          echo '# 确保文件在主机上可访问' >> build.sh
          echo 'chmod 755 sliver-server-centos5-i686' >> build.sh
          
          # 使脚本可执行
          chmod +x build.sh
          
          # 在Docker容器中运行构建
          docker run -v $(pwd):/build sliver-build /bin/sh -c "cd /build && ./build.sh 2>&1 | tee build.log || (echo '构建失败' && exit 1)"
          
      - name: Output build log (Success or Failure)
        if: always()
        run: |
          echo "构建日志输出:"
          cat build.log || echo "No build log found"
          
      - name: Prepare binary for upload
        run: |
          echo "确认二进制文件存在:"
          ls -la
          
          # 修复权限问题并确保二进制文件可执行
          if [ -f "./sliver-server-centos5-i686" ]; then
            echo "Binary found, fixing permissions"
            sudo chown $(id -u):$(id -g) ./sliver-server-centos5-i686
            sudo chmod +x ./sliver-server-centos5-i686
            
            # 测试二进制文件
            echo "测试二进制文件:"
            file ./sliver-server-centos5-i686
            ldd ./sliver-server-centos5-i686 || echo "Binary is static (expected)"
            
            # 移动到专用目录以方便上传
            mkdir -p ./artifacts
            cp ./sliver-server-centos5-i686 ./artifacts/
            ls -la ./artifacts/
          else
            echo "Binary NOT found in workspace"
            find . -name "sliver-server*"
            
            # 检查修补的文件是否正确
            echo "检查修补的文件是否正确："
            
            echo "查看configs/crack.go中的defaultMaxFileSize:"
            grep -n "defaultMaxFileSize" ./server/configs/crack.go || echo "未找到defaultMaxFileSize"
            grep -n "10737418240" ./server/configs/crack.go || echo "整数值已全部替换"
            grep -n "int64" ./server/configs/crack.go || echo "未找到int64转换"
            
            echo "显示lines附近的内容:"
            if [ -f ./server/configs/crack.go ]; then
              echo "======= 显示第104行附近的内容 ======="
              sed -n '99,110p' ./server/configs/crack.go
            fi
            
            echo "查看所有GetZigDir调用:"
            grep -n "GetZigDir" ./server/gogo/go.go || echo "未找到GetZigDir调用"
            
            echo "检查assets.go中的GetZigDir函数定义:"
            grep -n "func GetZigDir" ./server/assets/assets.go || echo "未找到GetZigDir函数定义"
            
            exit 1
          fi
      
      - name: Upload sliver server
        uses: actions/upload-artifact@v4
        with:
          name: sliver-server-centos5-i686
          path: ./artifacts/sliver-server-centos5-i686
          if-no-files-found: error
          compression-level: 6
          overwrite: false
      - name: Create README
        run: |
          # 使用echo命令创建README文件，避免heredoc语法问题
          echo '# Sliver Server for CentOS 5.11 i686' > README-centos5-i686.md
          echo '此构建专为老旧的CentOS 5.11 i686系统设计，构建设置如下：' >> README-centos5-i686.md
          echo '- 基于静态编译的Go应用程序' >> README-centos5-i686.md
          echo '- 使用Alpine进行交叉编译' >> README-centos5-i686.md
          echo '- 目标系统：Linux 2.6.18内核，glibc 2.5' >> README-centos5-i686.md
          echo '- 构建特性：' >> README-centos5-i686.md
          echo '  - 静态链接（无外部依赖）' >> README-centos5-i686.md
          echo '  - 32位i686架构' >> README-centos5-i686.md
          echo '  - 使用UPX压缩以减小体积' >> README-centos5-i686.md
          echo '## 使用方法' >> README-centos5-i686.md
          echo '1. 下载二进制文件' >> README-centos5-i686.md
          echo '2. 赋予执行权限：`chmod +x sliver-server-centos5-i686`' >> README-centos5-i686.md
          echo '3. 运行服务器：`./sliver-server-centos5-i686`' >> README-centos5-i686.md
          echo '首次运行时，服务器将生成所需的配置文件和证书。' >> README-centos5-i686.md
          echo '' >> README-centos5-i686.md
          echo '## 功能限制' >> README-centos5-i686.md
          echo '此版本使用了`no_assets`标签构建，意味着没有内置资源包（Go、编译器等）。' >> README-centos5-i686.md
          echo '如果需要使用implant生成功能，请将必要的资源手动放置在相应目录中。' >> README-centos5-i686.md
          echo '' >> README-centos5-i686.md
          echo '## 注意事项' >> README-centos5-i686.md
          echo '' >> README-centos5-i686.md
          echo '- 此二进制文件已经过静态编译，不依赖系统库' >> README-centos5-i686.md
          echo '- 为保证最佳兼容性，使用`-extldflags '"'"'-static'"'"'`构建' >> README-centos5-i686.md
          echo '- 使用UPX压缩，如运行时遇到问题，可尝试解压缩：`upx -d sliver-server-centos5-i686`' >> README-centos5-i686.md
          
          # 确保README也放入artifacts目录
          mkdir -p ./artifacts
          cp README-centos5-i686.md ./artifacts/
          
      - name: Upload README
        uses: actions/upload-artifact@v4
        with:
          name: sliver-server-centos5-i686-docs
          path: ./artifacts/README-centos5-i686.md
          if-no-files-found: warn
          compression-level: 6
          overwrite: false 
