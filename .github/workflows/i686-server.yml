name: Build Sliver Server for CentOS 5.11 i686

on:
  workflow_dispatch:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # 获取完整历史以便git describe能够工作
          
      - name: Set up Docker
        uses: docker/setup-buildx-action@v2
        
      - name: Create Dockerfile for Alpine
        run: |
          cat > Dockerfile.alpine << EOF
FROM golang:1.22.2-alpine3.19

# 安装基本构建工具和依赖
RUN apk add --no-cache build-base git ca-certificates upx curl bash zip unzip xz

# 设置工作目录
WORKDIR /build

# 设置环境变量
ENV CGO_ENABLED=0
ENV GOOS=linux
ENV GOARCH=386
EOF

      - name: Build Docker image
        run: docker build -t sliver-build -f Dockerfile.alpine .

      - name: Fix compilation errors
        run: |
          # 修复 configs/crack.go 中的整数溢出问题
          if [ -f ./server/configs/crack.go ]; then
            sed -i 's/defaultMaxFileSize := 10737418240/defaultMaxFileSize := int64(10737418240)/g' ./server/configs/crack.go
            sed -i 's/defaultMaxFileSize = 10737418240/defaultMaxFileSize = int64(10737418240)/g' ./server/configs/crack.go
            sed -i 's/: 10737418240,/: int64(10737418240),/g' ./server/configs/crack.go
            sed -i 's/10737418240)/int64(10737418240))/g' ./server/configs/crack.go
            
            # 打印修改后的文件，检查是否正确替换
            echo "检查修改后的 configs/crack.go 文件:"
            grep -n "10737418240" ./server/configs/crack.go || echo "整数值已全部替换"
          fi
          
          # 修复 server/gogo/go.go 中的 GetZigDir 调用
          if [ -f ./server/gogo/go.go ]; then
            # 替换所有没有参数的 GetZigDir 调用，添加 GOOS 和 GOARCH 参数
            sed -i 's/GetZigDir()/GetZigDir("linux", "386")/g' ./server/gogo/go.go
            
            # 打印修改后的文件，检查是否正确替换
            echo "检查修改后的 gogo/go.go 文件:"
            grep -n "GetZigDir" ./server/gogo/go.go
          fi

      - name: Prepare patched asset files
        run: |
          # 创建目录结构
          mkdir -p ./server/assets/
          
          # 创建修复 crack.go 的脚本
          cat > fix_crack.sh << EOF
#!/bin/bash
set -e

# 检查文件是否存在
if [ ! -f ./server/configs/crack.go ]; then
  echo "错误: crack.go 未找到"
  exit 1
fi

# 读取原始内容
ORIG_CONTENT=$(cat ./server/configs/crack.go)

# 显示原始内容
echo "原始内容:"
echo "$ORIG_CONTENT" | sed -n '100,110p'

# 替换所有整数值
NEW_CONTENT=$(echo "$ORIG_CONTENT" | sed 's/10737418240/int64(10737418240)/g')

# 检查替换结果
echo "替换后内容:"
echo "$NEW_CONTENT" | sed -n '100,110p'

# 保存到新文件
echo "$NEW_CONTENT" > ./server/configs/crack.go.new

# 验证替换是否成功
if grep -q "int64(10737418240)" ./server/configs/crack.go.new; then
  echo "替换成功，应用新文件"
  mv ./server/configs/crack.go.new ./server/configs/crack.go
else
  echo "替换失败，尝试直接替换特定行"
  # 替换特定的第104行
  LINE_104=$(echo "$ORIG_CONTENT" | sed -n '104p')
  FIXED_LINE_104=$(echo "$LINE_104" | sed 's/10737418240/int64(10737418240)/g')
  
  echo "原始第104行: $LINE_104"
  echo "修复后第104行: $FIXED_LINE_104"
  
  # 构建新文件
  echo "$ORIG_CONTENT" | sed "104s/.*/${FIXED_LINE_104}/" > ./server/configs/crack.go.new2
  mv ./server/configs/crack.go.new2 ./server/configs/crack.go
fi

# 最终检查
grep -n "defaultMaxFileSize" ./server/configs/crack.go
grep -n "10737418240" ./server/configs/crack.go || echo "所有整数值已替换"
EOF
          
          # 使脚本可执行并运行
          chmod +x fix_crack.sh
          ./fix_crack.sh
          
          # 创建assets补丁脚本
          cat > assets-patch.sh << EOF
#!/bin/bash
set -e

# 创建assets_generate.go文件
cat > ./server/assets/assets_generate.go << EOF
//go:build generate
// +build generate

package assets

// 这个文件用于go generate命令，但我们在编译时使用no_assets标签跳过它
// 此文件不包含实际功能，仅为了满足编译要求
EOF

# 创建带有所有必要函数的assets.go文件
cat > ./server/assets/assets.go << EOF
//go:build !generate && no_assets
// +build !generate,no_assets

package assets

import (
  "errors"
  "io/fs"
  "os"
  "path/filepath"
  "log"
  "runtime"
  "strings"
)

// 定义常量
const (
  GoDirName = "go"
  ZigDirName = "zig"
)

// 自定义日志记录器
type Logger struct {
    stdLogger *log.Logger
}

func (l *Logger) Info(args ...interface{}) {
    l.stdLogger.Println(args...)
}

func (l *Logger) Infof(format string, args ...interface{}) {
    l.stdLogger.Printf(format, args...)
}

func (l *Logger) Warn(args ...interface{}) {
    l.stdLogger.Println("[WARN]", args)
}

func (l *Logger) Warnf(format string, args ...interface{}) {
    l.stdLogger.Printf("[WARN] "+format, args...)
}

func (l *Logger) Error(args ...interface{}) {
    l.stdLogger.Println("[ERROR]", args)
}

func (l *Logger) Errorf(format string, args ...interface{}) {
    l.stdLogger.Printf("[ERROR] "+format, args...)
}

func (l *Logger) Debug(args ...interface{}) {
    l.stdLogger.Println("[DEBUG]", args)
}

func (l *Logger) Debugf(format string, args ...interface{}) {
    l.stdLogger.Printf("[DEBUG] "+format, args...)
}

// 创建自定义日志记录器实例
var setupLog = &Logger{
    stdLogger: log.New(os.Stderr, "assets: ", log.LstdFlags),
}

// Setup - 初始化资产
func Setup() {
    setupLog.Infof("[assets] Skip loading embedded assets (using no_assets tag)")
}

// Asset - 实现Asset函数
func Asset(name string) ([]byte, error) {
    setupLog.Debugf("Asset called for %s (not implemented in no_assets build)", name)
    return []byte{}, errors.New("assets not available in this build")
}

// AssetDir - 实现AssetDir函数
func AssetDir(name string) ([]string, error) {
    setupLog.Debugf("AssetDir called for %s (not implemented in no_assets build)", name)
    return []string{}, errors.New("assets not available in this build")
}

// AssetInfo - 实现AssetInfo函数
func AssetInfo(name string) (fs.FileInfo, error) {
    setupLog.Debugf("AssetInfo called for %s (not implemented in no_assets build)", name)
    return nil, errors.New("assets not available in this build")
}

// GetTrafficEncoderDir - 获取流量编码器目录
func GetTrafficEncoderDir() string {
    return filepath.Join(".", "traffic-encoders")
}

// GetRootAppDir - 获取应用程序根目录
func GetRootAppDir() string {
    exePath, err := os.Executable()
    if err != nil {
        setupLog.Errorf("Failed to get executable path: %s", err)
        return "."
    }
    return filepath.Dir(exePath)
}

// GetZigDir - 获取Zig目录
func GetZigDir(targetOS string, targetArch string) string {
    zigDir := filepath.Join(GetRootAppDir(), ".sliver-client", "zig")
    if _, err := os.Stat(zigDir); os.IsNotExist(err) {
        os.MkdirAll(zigDir, 0700)
    }
    return zigDir
}

// 定义assetsFs变量
var assetsFs = &AssetFS{
    Asset:    Asset,
    AssetDir: AssetDir,
    AssetInfo: AssetInfo,
}

// AssetFS - 文件系统接口实现
type AssetFS struct {
    Asset    func(name string) ([]byte, error)
    AssetDir func(name string) ([]string, error)
    AssetInfo func(name string) (fs.FileInfo, error)
}

// ReadFile - 添加的为了兼容assets-helpers.go的方法
func (a *AssetFS) ReadFile(name string) ([]byte, error) {
    return a.Asset(name)
}

// 为了避免编译器报错，添加缺失的一些目录函数
func GetGoDirPath(goOS string, goArch string) string {
    return filepath.Join(".", GoDirName, goOS, goArch) 
}

func GetGoZipPath(goOS string, goArch string) string {
    return filepath.Join(GetGoDirPath(goOS, goArch), "go.zip")
}

func GetSGNPath(goOS string, goArch string) string {
    return filepath.Join(".", "sgn", goOS, goArch)
}

func GetGarblePath(goOS string, goArch string) string {
    return filepath.Join(".", "garble", goOS, goArch) 
}

func GetZigPath(goOS string, goArch string) string {
    return filepath.Join(".", ZigDirName, goOS, goArch)
}
EOF

# 修复assets-helpers.go
# 检查原始文件是否存在，如果存在则备份
if [ -f ./server/assets/assets-helpers.go ]; then
    cp ./server/assets/assets-helpers.go ./server/assets/assets-helpers.go.bak
    # 尝试修复ReadFile错误
    sed -i 's/assetsFs\.ReadFile/assetsFs\.Asset/g' ./server/assets/assets-helpers.go
fi
EOF
          
          # 使脚本可执行并运行
          chmod +x assets-patch.sh
          ./assets-patch.sh
          
          # 检查修补后的函数
          echo "检查修补后的函数:"
          grep -n "setupLog" ./server/assets/assets.go || echo "setupLog未找到"
          grep -n "GetTrafficEncoderDir" ./server/assets/assets.go || echo "GetTrafficEncoderDir未找到"
          grep -n "GoDirName" ./server/assets/assets.go || echo "GoDirName未找到"
          grep -n "GetRootAppDir" ./server/assets/assets.go || echo "GetRootAppDir未找到"
          grep -n "GetZigDir" ./server/assets/assets.go || echo "GetZigDir未找到"

      - name: Build Sliver for CentOS 5.11
        run: |
          # 创建build.sh脚本
          cat > build.sh << EOF
#!/bin/sh
set -e

# 配置Git安全目录
git config --global --add safe.directory /build

# 在容器内修复configs/crack.go中的整数溢出问题
if [ -f /build/server/configs/crack.go ]; then
  echo "===== 在构建容器中修复crack.go ====="
  cat /build/server/configs/crack.go | sed 's/10737418240/int64(10737418240)/g' > /tmp/crack.go
  mv /tmp/crack.go /build/server/configs/crack.go
  
  # 显示修改后的文件
  echo "第104行附近内容:"
  sed -n '100,110p' /build/server/configs/crack.go 
fi

# 设置版本信息
export VERSION=$(git describe --abbrev=0 || echo "v0.0.0")
export COMPILED_AT=$(date +%s)
export RELEASES_URL="https://api.github.com/repos/BishopFox/sliver/releases"
export GIT_COMMIT=$(git rev-parse HEAD || echo "unknown")
export GIT_DIRTY=$(git diff --quiet || echo 'Dirty')
export ARMORY_PUBLIC_KEY="RWSBpxpRWDrD7Fe+VvRE3c2VEDC2NK80rlNCj+BX0gz44Xw07r6KQD9L"
export ARMORY_REPO_URL="https://api.github.com/repos/sliverarmory/armory/releases"

# 设置构建标志
export LDFLAGS="-s -w \\
  -extldflags '-static -Wl,--strip-all' \\
  -X github.com/bishopfox/sliver/client/version.Version=\${VERSION} \\
  -X github.com/bishopfox/sliver/client/version.CompiledAt=\${COMPILED_AT} \\
  -X github.com/bishopfox/sliver/client/version.GithubReleasesURL=\${RELEASES_URL} \\
  -X github.com/bishopfox/sliver/client/version.GitCommit=\${GIT_COMMIT} \\
  -X github.com/bishopfox/sliver/client/version.GitDirty=\${GIT_DIRTY} \\
  -X github.com/bishopfox/sliver/client/assets.DefaultArmoryPublicKey=\${ARMORY_PUBLIC_KEY} \\
  -X github.com/bishopfox/sliver/client/assets.DefaultArmoryRepoURL=\${ARMORY_REPO_URL}"

# 确保vendor目录存在
go mod vendor || echo "Vendor modules already present"

# 构建服务器 - 使用no_assets标签跳过资产嵌入
echo "正在为CentOS 5.11 i686构建sliver-server..."
go build -mod=vendor -trimpath -tags "netgo,osusergo,no_assets,server" -ldflags "\${LDFLAGS}" -o /build/sliver-server-centos5-i686 ./server

# 使用UPX压缩二进制文件
echo "压缩二进制文件..."
upx -9 /build/sliver-server-centos5-i686

# 验证构建结果
file /build/sliver-server-centos5-i686

# 检查文件是否存在
ls -la /build/sliver-server-centos5-i686

# 确保文件有执行权限
chmod +x /build/sliver-server-centos5-i686
EOF
          
          # 使脚本可执行
          chmod +x build.sh
          
          # 在Docker容器中运行构建
          docker run -v $(pwd):/build sliver-build /bin/sh -c "cd /build && (./build.sh 2>&1 | tee /tmp/build.log) && ls -la /build/ && cp -v /build/sliver-server-centos5-i686 /build/ || (echo '======= 构建错误 =======' && cat /tmp/build.log && false)"

      - name: Verify patched files
        if: failure()
        run: |
          echo "构建失败，检查文件是否正确修补:"
          
          echo "检查configs/crack.go中的defaultMaxFileSize:"
          grep -n "defaultMaxFileSize" ./server/configs/crack.go || echo "defaultMaxFileSize未找到"
          grep -n "10737418240" ./server/configs/crack.go || echo "所有整数值已替换"
          grep -n "int64" ./server/configs/crack.go || echo "未找到int64转换"
          
          echo "显示第104行附近内容:"
          if [ -f ./server/configs/crack.go ]; then
            echo "======= 第104行附近内容 ======="
            sed -n '99,110p' ./server/configs/crack.go
          fi
          
          echo "检查GetZigDir调用:"
          grep -n "GetZigDir" ./server/gogo/go.go || echo "未找到GetZigDir调用"
          
          echo "检查assets.go中的GetZigDir函数定义:"
          grep -n "func GetZigDir" ./server/assets/assets.go || echo "GetZigDir函数未找到"
          
          echo "检查错误日志:"
          cat /tmp/build.log || echo "未找到构建日志"

      - name: Test binary compatibility
        run: |
          # 列出当前目录中的文件
          echo "当前目录中的文件:"
          ls -la ./
          
          # 验证二进制文件是否为静态链接的32位可执行文件
          if [ -f ./sliver-server-centos5-i686 ]; then
            file ./sliver-server-centos5-i686
            ldd ./sliver-server-centos5-i686 || echo "二进制文件是静态的(预期结果)"
          else
            echo "未在预期位置找到二进制文件，检查其他位置..."
            find ./ -name "sliver-server-centos5-i686" -type f
          fi
      
      # 确保文件存在并具有正确的权限
      - name: Verify file existence and permissions
        run: |
          ls -la ./sliver-server-centos5-i686 || echo "未在预期位置找到二进制文件"
          [ -f ./sliver-server-centos5-i686 ] && chmod +x ./sliver-server-centos5-i686

      - name: Upload sliver server
        uses: actions/upload-artifact@v3
        with:
          name: sliver-server-centos5-i686
          path: ./sliver-server-centos5-i686
          if-no-files-found: warn
          
      - name: Create README
        run: |
          cat > README-centos5-i686.md << EOF
# Sliver Server for CentOS 5.11 i686

此构建专为老旧的CentOS 5.11 i686系统设计，构建设置如下：

- 基于静态编译的Go应用程序
- 使用Alpine进行交叉编译
- 目标系统：Linux 2.6.18内核，glibc 2.5
- 构建特性：
  - 静态链接（无外部依赖）
  - 32位i686架构
  - 使用UPX压缩以减小体积

## 使用方法

1. 下载二进制文件
2. 赋予执行权限：\`chmod +x sliver-server-centos5-i686\`
3. 运行服务器：\`./sliver-server-centos5-i686\`

首次运行时，服务器将生成所需的配置文件和证书。

## 功能限制

此版本使用了\`no_assets\`标签构建，意味着没有内置资源包（Go、编译器等）。
如果需要使用implant生成功能，请将必要的资源手动放置在相应目录中。

## 注意事项

- 此二进制文件已经过静态编译，不依赖系统库
- 为保证最佳兼容性，使用\`-extldflags '-static'\`构建
- 使用UPX压缩，如运行时遇到问题，可尝试解压缩：\`upx -d sliver-server-centos5-i686\`
EOF

      - name: Upload README
        uses: actions/upload-artifact@v3
        with:
          name: sliver-server-centos5-i686-docs
          path: README-centos5-i686.md 
